---
title: "mcxs-a2-g5 report"
author: "Alex Rendell, Xinyu Dang, Gavin Williams"
date: "29/04/2022"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#**Macroeconometrics ECOM9007**
##Assignment 2 - Group 5
Prepared by Alex Rendell, Gavin Williams, Xinyu Dang


###Exercise 1 

In this section, we (i) list and justify the selection of nine macroeconomic variables used to forecast 'Hours Worked', (ii) Source and transform the data for the ten variables into a data matrix, and (iii) Plot the data matrix and comment with observations.

**Selections**


``` {r}
# INSTALLING REQUIRED PACKAGES
library(readrba)
library(readabs)
library(tidyr)
library(dplyr)
library(ggplot2)
library(lubridate)
library(reticulate)
library(mvtnorm)
library(HDInterval)
set.seed(123456)

# DATA COLLECTION AND TRANSFORMING
############################################################
##VAR1
HOURS               = read_abs(series_id ="A2304428W")
HOURS               = HOURS %>%slice(-c(1:101))
HOURS               = HOURS[c(4,6)]

##VAR2
HHSAVINGS           = read_abs(series_id = "A2323382F")
HHSAVINGS           = HHSAVINGS %>%slice(-c(1:101))
HHSAVINGS           = HHSAVINGS[c(4,6)]

##VAR3
EMPLOYMENT          = read_abs(series_id = "A2454521V")
EMPLOYMENT          = EMPLOYMENT %>%slice(-c(1:109))
EMPLOYMENT          = EMPLOYMENT[c(4,6)]

##VAR4
CPI_CHANGE_Q        = read_abs(series_id = "A2325850V")
CPI_CHANGE_Q        = CPI_CHANGE_Q %>%slice(-c(1:153))
CPI_CHANGE_Q        = CPI_CHANGE_Q[c(4,6)]

##VAR5
REAL_LABOUR_COST    = read_abs(series_id = "A2433071F")
REAL_LABOUR_COST    = REAL_LABOUR_COST %>%slice(-c(1:5))
REAL_LABOUR_COST    = REAL_LABOUR_COST[c(4,6)]

##VAR6
GDP_PCT_CHANGE      = read_abs(series_id = "A2304370T")
GDP_PCT_CHANGE      = GDP_PCT_CHANGE %>%slice(-c(1:101))
GDP_PCT_CHANGE      = GDP_PCT_CHANGE[c(4,6)]

##VAR7
PUBLIC_CAPITAL      = read_abs(series_id = "A2454459T")
PUBLIC_CAPITAL      = PUBLIC_CAPITAL %>%slice(-c(1:109))
PUBLIC_CAPITAL      = PUBLIC_CAPITAL[c(4,6)]

##VAR8
INVENTORIES         = read_abs(series_id = "A3538852F")
INVENTORIES         = INVENTORIES %>%slice(-c(1:5))
INVENTORIES         = INVENTORIES[c(4,6)]

##VAR9
DISP_INC_PC         = read_abs(series_id = "A2304416L")
DISP_INC_PC         = DISP_INC_PC %>% slice(-c(1:101))
DISP_INC_PC         = DISP_INC_PC[c(4,6)]

##VAR10
TOT                 = read_abs(series_id = "A2304400V")
TOT                 = TOT %>% slice(-c(1:101))
TOT                 = TOT[c(4,6)]

# Create Y and X
############################################################
y_VEC1              = merge(HOURS, HHSAVINGS, by = 'date')
y_VEC2              = merge(EMPLOYMENT, CPI_CHANGE_Q, by = 'date')
y_VEC3              = merge(REAL_LABOUR_COST, GDP_PCT_CHANGE, by ='date')
y_VEC4              = merge(PUBLIC_CAPITAL, INVENTORIES, by ='date')
y_VEC5              = merge(DISP_INC_PC, TOT, by ='date')

y1                  = merge(y_VEC1, y_VEC2, by = 'date')
y2                  = merge(y_VEC3, y_VEC4, by = 'date')
y3                  = merge(y1, y2, by ='date')

y                   = merge(y3, y_VEC5, by = 'date') 
y                   = y %>% slice(-c(1:8))
y                   = ts(y[,c(2:11)], start = c(1986,4), frequency = 4, names=c("Hours Worked","Household_Savings","Employment",
                                                                                "CPI Change","Real Labour Costs",
                                                                                "GDP % Change","Public Capital","Inventories",
                                                                                "Disposable Income","Terms of Trade"))
#Plot macro data and comment on trends
plot(y)

```
**Observations**



\newpage

###Exercise 2

In this section we document the likelihood function of the model, and the probability density function of A and \Sigma which follows joint matrix-variate normal-inverse Wishart distribution, and includes two hyperparameters.

![](Exercise2.png)

We also specify the parameters determining the prior distribution matrices \bar{A}, \bar{V}, \bar{S} and \bar{v}.

\newpage

# Exercise 3 - Joint conditional posterior distribuion

![](Exercise3-1.png)

![](Exercise3-2.png)

![](Exercise3-3.png)

\newpage

# Exercise 4

![](Exercise4.png)

\newpage

# Exercise 5

![](Exercise5-1.png) 

![](Exercise5-2.png) 

![](Exercise5-3.png) 

<<<<<<< Updated upstream
![](Exercise5-4.png) 
![](Exercise5-5.png)
\newpage
# Exercise 6
In this section we explain our Gibbs Sampler and the use of the full conditional posterior distributions.

# Exercise 7
```{r}
# setup
############################################################
N                   = 10
p                   = 4
K                   = 1+p*N
S                   = 50000
h                   = #TBD
  
TT                  = nrow(Y)
T                   = TT - 1

# Create Y and X
############################################################
Y                   = ts(y[(p+1):nrow(y),],start = c(1994,3), frequency = 4)
X                   = matrix(1,nrow(Y),1)
X                   = cbind(X,
                            y[5:nrow(y)-1,],
                            y[5:nrow(y)-2,],
                            y[5:nrow(y)-3,],
                            y[5:nrow(y)-4,]
                            )
    

## MLE
A_HAT                 = (1/((t(X)%*%X)))%*%t(X)%*%Y
SIGMA_HAT             = t(Y-X%*%A_HAT)%*%(Y-X%*%A_HAT)
round(A_HAT,3)
round(SIGMA_HAT,3)
round(cov2cor(SIGMA_HAT),3)

# PRIOR DISTRIBUTION
############################################################
KAPPA_P_A             = 100
KAPPA_P_E             = 0.02^2
A_MEAN_PRI            = matrix(0, nrow(A_HAT),ncol(A_HAT))
A_MEAN_PRI[2:11,]     = diag(10)
V_PRIOR               = diag(c(KAPPA_P_E,KAPPA_P_A*((1:p)^(-2))%x%t(rep(1,N))))   # COL SPECIFIC VAR
V_PRIOR_INV           = diag(1/c(KAPPA_P_E,KAPPA_P_A*((1:p)^(-2))%x%t(rep(1,N))))

S_PRIOR               = diag(diag(SIGMA_HAT)) 
NU_PRIOR              = N+1

A_PRIOR               = matrix(0, nrow(A_HAT),ncol(A_HAT))
SIGMA_PRIOR           = diag(10)
SIGMA_PRIOR_INV       = solve(SIGMA_PRIOR)

#SPECIFYING HYPER-PARAMETERS
hyper                 = list(1,1,1,1,A_MEAN_PRI,S_PRIOR,V_PRIOR, NU_PRIOR)
names(hyper)          = c("S_PRIOR_Ka","V_PRIOR_KA","ALPHA_PRIOR_Ke","BETA_PRIOR_Ke","A_MEAN_PRI","S_PRIOR", "V_PRIOR", "NU_PRIOR")


#POSTERIOR DRAWS
posterior_A           = array(NA, c(S, K, N))
posterior_E           = array(NA, c(N, N, S))
posterior_ka          = matrix(NA, S)
posterior_ke          = matrix(NA, S)

GIBBS_SAMPLER = function(S, Y, X , hyper){

  for (s in 1:S){
    # HYPER-PARAMETER ESTIMATION -- K_E
    alpha_bar_ke        = hyper$ALPHA_PRIOR_Ke + ((hyper$V_PRIOR*N))/2
    beta_bar_ke         = hyper$BETA_PRIOR_Ke + 0.5*sum(diag(hyper$S_PRIOR%*%solve(SIGMA_PRIOR)))
  
    # SAMPLING -- K_E
    KAPPA_P_E           = rgamma(1, shape = alpha_bar_ke, scale = 1/beta_bar_ke)
    posterior_ke        = KAPPA_P_E
    
  
  
    # HYPER-PARAMETER ESTIMATION -- K_A
    s_bar_ka            = sum(diag((solve(SIGMA_PRIOR)%*%t(A_PRIOR-hyper$A_MEAN_PRI))%*%(A_PRIOR-hyper$A_MEAN_PRI))) + hyper$S_PRIOR_Ka
    v_bar_ka            = hyper$V_PRIOR_KA + N*K
  
    # SAMPLING -- K_A
    KAPPA_P_A           = s_bar_ka/rchisq(1, v_bar_ka)
    posterior_ka        = KAPPA_P_A
  
    # PARAMETERS OF MVNIW POSTERIOR
    V_bar_inv           = crossprod(X) + V_PRIOR_INV*(1/KAPPA_P_A)
    V_bar               = solve(V_bar_inv)
    A_bar               = V_bar%*%(t(X)%*%Y + solve(KAPPA_P_A*V_bar)%*%hyper$A_MEAN_PRI)
    
    S_bar         = crossprod(Y) + KAPPA_P_E*hyper$S_PRIOR + t(hyper$A_MEAN_PRI)%*%solve((KAPPA_P_A*hyper$V_PRIOR))%*%hyper$A_MEAN_PRI - t(A_bar)%*%V_bar_inv%*%A_bar
    #S_bar_inv           = solve(S_bar)
    S_bar              = 0.5*(S_bar + t(S_bar))
    S_bar_chol         = chol(S_bar)
    S_bar_inv          = backsolve(S_bar_chol, forwardsolve(t(S_bar_chol), diag(N)))
    nu_bar              = T + NU_PRIOR

    # SAMPLE -- aux_A & aux_E
    L                   = t(solve(chol(V.bar.inv)))
    SIGMA_POST          = solve(rWishart(1, df = nu_bar, Sigma =S_bar_inv)[,,1])
    draw.norm           = array(rnorm(prod(N*K)),c(K,N))
    A_POST              = A_bar + L%*%draw.norm%*% chol(SIGMA_POST)
                          
    round(apply(A_POST,1:2, mean),3)
                          
    posterior_ka[s] = KAPPA_P_A
    posterior_ke[s] = KAPPA_P_E
    posterior_A[s,,] = A_POST
    posterior_E[,,s] = SIGMA_POST
  }

  # OUTPUT  
  return(
    list(
      A           = posterior_A,
      E           = posterior_E,
      Ka          = posterior_ka,
      Ke          = posterior_ke,
    )
  )
}

```

# Exercise 6

# Exercise 7

# Exercise 8

# Exercise 9
